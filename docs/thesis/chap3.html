<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.22">
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>

                                                                                      
<title>Chapter 3: Numerical Simulation of Collisionless Shocks</title>

 <h1><a name="tth_chAp3">
Chapter 3 </a><br />Numerical Simulation of Collisionless Shocks</h1>
<a name="chap:simulation">
</a>

<div class="p"></div>
The Rankine-Hugoniot equations (Section <a href="#sec:RH_relations">1.4.1</a>) describe macroscopic shock structure in terms of conserved quantities, but do not provide any description of the finite width of the shock transition or the field structures that appear there.  It is difficult to produce analytic descriptions of the micro-physics of shock structure, since many of the processes occurring at the shock front are non-linear and difficult to describe analytically.  In order to study the shock transition, therefore, numerical simulation becomes a useful tool.

<div class="p"></div>
I this chapter, we describe various classes of plasma simulation algorithms and discuss the different methods that can be used to stimulate the formation of a shock wave.  We discuss in detail the hybrid model for simulating plasmas and the CAM-CL hybrid algorithm, which we use in this thesis.  In order to examine electron behaviour in the shock, we use a test particle code to study electron motion in the fields generated by our hybrid code.  We therefore describe and compare a number of algorithms for integrating electron trajectories and interpolating fields in time and space.

<div class="p"></div>
 <h2><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;Shock Simulation Methods</h2>

<div class="p"></div>
In order to simulate a shock, we need to determine a set of initial conditions that will result in the creation of a shock.  We also need to choose a plasma simulation model to evolve these initial conditions in time.  We describe various classes of plasma simulation algorithms and discuss the different methods that can be used to stimulate the formation of a shock wave.  We shall discuss the plasma simulation model first, since this may influence the choice of initial conditions.

<div class="p"></div>
     <h3><a name="tth_sEc3.1.1">
3.1.1</a>&nbsp;&nbsp;Plasma simulation models</h3>

<div class="p"></div>
Plasma simulation models work by using Maxwell's equations to calculate the electric and magnetic fields from the currents and charges.  In a kinetic simulation, these come from the moments of the particle distribution.  The particle distribution itself can be treated in a variety of ways.  The particles can be simulated directly as a collection of "macro-particles", they can be approximated as a phase space distribution, or a fluid approximation can be used to represent the particles in terms of their moments.  Below we describe the characteristics of a variety of different models and discuss which is most suitable for our simulations.

<div class="p"></div>
When selecting a plasma simulation model, we should consider which physical processes are relevant, and which will have little impact on what we are studying.  In terms of collisionless shocks, there are a number of issues.  The first is that the profile of the shock transition, including the shock foot, ramp and overshoot, is produced by kinetic ion physics, not electron physics.  We also need to ensure that the simulation box can be large enough to enclose any field structure caused by ion phenomena.  Since we are hoping to study electron acceleration, we also need the simulation to run for sufficiently long that electrons can interact with, and escape from, the shock.  Finally, we should consider the role that electron kinetic physics might play in the electron acceleration process.

<div class="p"></div>

<h4>Magnetohydrodynamics</h4>

<div class="p"></div>
A typical MHD code will model the plasma as a fluid using only first order moments of the distribution function, so the fluid's properties are characterised in terms of its position and velocity.  The MHD equations for a perfectly conducting (ideal) plasma are shown below.  The plasma fluid is described by the continuity, momentum and energy equations respectively:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;D <font face="symbol">r</font
>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>Dt<br /></td><td nowrap="nowrap" align="center">
 = <font face="symbol">-</font
> <font face="symbol">r</font
><font face="symbol">Ñ</font
>&#183;<b>U</b></td></tr></table>
</td><td width="1%">(3.1)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="symbol">r</font
></td><td nowrap="nowrap" align="center">
&nbsp;D <b>U</b>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>Dt<br /></td><td nowrap="nowrap" align="center">
 = <font face="symbol">-</font
> <font face="symbol">Ñ</font
>p + </td><td nowrap="nowrap" align="center">
&nbsp;1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">m</font
><sub>0</sub><br /></td><td nowrap="nowrap" align="center">
(<font face="symbol">Ñ</font
>&times;<b>B</b>) &times;<b>B</b></td></tr></table>
</td><td width="1%">(3.2)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;D
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>Dt<br /></td><td nowrap="nowrap" align="center">
(p <font face="symbol">r</font
><sup><font face="symbol">-</font
><font face="symbol">g</font
></sup>) = 0</td></tr></table>
</td><td width="1%">(3.3)</td></tr></table>


The magnetic field is described by two equations that are derived from Maxwell's equations:
<a name="equn:MHD_B_evoln">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">¶</font
><b>B</b>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">¶</font
>t<br /></td><td nowrap="nowrap" align="center">
 = <font face="symbol">Ñ</font
>&times;(<b>U</b> &times;<b>B</b>)</td></tr></table>
</td><td width="1%">(3.4)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="symbol">Ñ</font
>&times;<b>B</b> = <font face="symbol">m</font
><sub>0</sub> <b>J</b></td></tr></table>
</td><td width="1%">(3.5)</td></tr></table>


The electric field is not described in these equations, although it can be calculated from Equation <a href="#equn:MHD_B_evoln">3.4</a>.

<div class="p"></div>
Plasmas can be simulated under the MHD fluid approximation by evolving the MHD equations stepwise.  Such MHD codes only require the storage and evolution of two scalar and two vector quantities for each grid cell.  They are therefore well suited to very large computational domains and can be used to examine the macroscopic behaviour of plasma parameters over large distances.  These codes do not, however, take into account the form of the particle distribution function and cannot therefore take into account kinetic processes.  This makes them much less suitable for studying boundaries and transitions, such as the shock surface, where the micro-physics of the particle distribution is responsible for the field structure.

<div class="p"></div>

<h4>Vlasov equation</h4>

<div class="p"></div>
The Boltzmann equation, which describes the evolution of the particle distribution function, f<sub>s</sub>, in phase space and incorporates all kinetic effects, is
<a name="equn:cless_vlasov">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">¶</font
>f<sub>s</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">¶</font
>t<br /></td><td nowrap="nowrap" align="center">
+ <b>v</b>&#183;<font face="symbol">Ñ</font
>f<sub>s</sub> + </td><td nowrap="nowrap" align="center">
&nbsp;q<sub>s</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>m<sub>s</sub><br /></td><td nowrap="nowrap" align="center">
(<b>E</b> + <b>v</b> &times;<b>B</b>) &#183;</td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">¶</font
>f<sub>s</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">¶</font
><b>v</b><br /></td><td nowrap="nowrap" align="center">
 = </td><td align="left" class="cl"><font face="symbol">
æ<br />è
</font></td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">¶</font
>f<sub>s</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">¶</font
>t<br /></td><td align="left" class="cl"><font face="symbol">
ö<br />ø
</font></td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><br />
<font size="-1">coll</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.6)</td></tr></table>


The collision term on the right hand side of the equation is set to zero for collisionless plasmas, yielding the Vlasov equation.  In Vlasov codes, it is the phase space distribution of particles that is modelled.  The distribution function of each particle species is calculated on a grid at each individual point in phase space, f(<b>x</b>,<b>v</b>,t).  These distribution functions are then evolved using the governing differential equations, so that ion and electron kinetic physics is simulated in a self-consistent manner.

<div class="p"></div>
Vlasov codes must therefore use a time step that allows the electron gyroperiod to be resolved.  A particle's gyroperiod is given by:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="symbol">W</font
><sub>s</sub> = </td><td nowrap="nowrap" align="center">
&nbsp;q<sub>s</sub>B
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>m<sub>s</sub><br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.7)</td></tr></table>


The proton-electron mass ratio is m<sub>p</sub>/m<sub>e</sub>  <font face="symbol">»</font
> 1800.  This places a huge constraint on Vlasov codes, since the simulation of ion kinetic effects using electron time scales requires the number of time steps to increase by a factor of 1800.  A similar argument applies to electron and ion length scales.  This can make it difficult to obtain quantitative results for processes such as electron acceleration in shocks which depend on the interaction of electron and ion scale phenomena.  

<div class="p"></div>
An additional drawback to the Vlasov method is that a great deal of information is required in order to adequately represent the distribution functions.  This is a particular problem at the shock transition where ion temperatures can increase by factors of around fifty, requiring large grid domains in velocity.  It would be very difficult to represent adequately the distribution function over such a large range of velocity, making Vlasov codes unsuitable for our simulations.

<div class="p"></div>

<h4>Full particle codes</h4>

<div class="p"></div>
In contrast to the MHD fluid approximation, full particle codes simulate both ion and electron species as a collection of macroparticles.  This means that, in common with Vlasov codes, both ion and electron kinetic physics are treated in a self-consistent manner.  In contrast to Vlasov codes, however, there is no discretisation of velocity.  Full particle codes are therefore better at modelling processes, such as particle acceleration at shocks, in which a considerable fraction of the particle population have trajectories that carry them through a large velocity range.  

<div class="p"></div>
In common with Vlasov codes, full particle codes also need to be run with time and length scales that can model both ion and electron phenomena.  In order to overcome this, the mass ratio is often artificially lowered to a value where electron and ion frequencies are adequately separated, but computational expense is more reasonable.  For example, <a href="#kraussvarban++95" name="CITEkraussvarban++95">Krauss-Varban <em>et&nbsp;al.</em> [1995]</a> used a mass ratio of m<sub>p</sub>/m<sub>e</sub> = 400 to run a 20,000 time step quasi-perpendicular shock simulation, lasting 6 <font face="symbol">W</font
><sub>i</sub><sup><font face="symbol">-</font
>1</sup>.  In our simulations, however, we are attempting to accelerate electrons to considerable energies at which their gyroradii become comparable with that of a thermal proton.  At these energies we might expect coupling between electron trajectories and ion processes, so altering the mass ratio and hence the associated length scales would make it difficult to compare our results with observations.

<div class="p"></div>
Electrons interact with the shock for a number of ion gyroperiods and over ion distance scales.  It would be difficult to run a full particle code for sufficiently long and over sufficient distances to study electron acceleration effectively.  It would also be difficult to have sufficient disk storage for the fields required for a test particle simulation.  This is because, in order to resolve electron scale processes, the fields would need to be stored on electron time scales.  The only way to run a test particle simulation would therefore be to run the test particle code concurrently with the full particle simulation.  This would be computationally very complicated, would impose large memory constraints, and would be inefficient in terms of varying the test particle initial conditions.

<div class="p"></div>
Full particle codes also suffer from noise due to the approximation of a large number of particles by a small number of macroparticles.  Although this affects all simulations that use macroparticles, it can be particularly acute for full particle codes because the already severe computational constraints mean that the number of particles per cell is kept as low as possible.  This can introduce a high level of artificial electron scattering.

<div class="p"></div>
<a href="#lembege+savoini99" name="CITElembege+savoini99">Lembege &amp; Savoini [1999]</a> ran simulations of electron acceleration at shocks with a mass ratio of m<sub>p</sub>/m<sub>e</sub>  <font face="symbol">»</font
> 40 and with an initial particle density of 4 particles per cell.  The duration of the simulations was around 18 &nbsp;<font face="symbol">W</font
><sub>i</sub><sup><font face="symbol">-</font
>1</sup>, so that electron acceleration could be studied.  The simulation box was, however, too narrow to observe ion scale ripples.  They found that electron scale ripples were produced at the shock front, which they believe are due to the excitation of lower-hybrid waves.  They also found that electron heating varied with <font face="symbol">q</font
><sub><span class="roman">B</span><sub><span class="roman">n</span></sub></sub>, but that this relationship depended on the mass ratio.  This demonstrates that full particle codes are able to simulate shock properties on electron scales.  This is, however, at a cost of introducing numerical dependencies that make any comparison with observations very difficult.

<div class="p"></div>
Full particle codes are, at first sight, an attractive option.  The practical restrictions placed on us by having finite computational resources, however, mean that they are not suitable for the study of electron acceleration in shocks.

<div class="p"></div>

<h4>Hybrid approximation</h4>

<div class="p"></div>
Hybrid codes provide a compromise between the Vlasov and full particle methods.  In a hybrid code, ions are treated as macroparticles, whilst electrons are simulated as a fluid.  Electron kinetics are thus neglected and modes such as lower-hybrid waves cannot be simulated.  A hybrid code is also unable to model electron scale ripples, which are seen in some full particle simulations.  Hybrid codes suffer from noise in a similar way to full particle codes.  It is, however, more computationally feasible to increase the number of particles per cell, so this noise may be reduced.  A clear advantage of hybrid codes is the relative ease with which time scales that are sufficient for electron acceleration may be simulated.

<div class="p"></div>
A hybrid algorithm is generated using the following equations.  The velocity, <b>v</b><sub>s</sub>, of a particle of species s is

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;d<b>x</b><sub>s</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>dt<br /></td><td nowrap="nowrap" align="center">
=<b>v</b><sub>s</sub></td></tr></table>
</td><td width="1%">(3.8)</td></tr></table>


We are interested in the electromagnetic behaviour of the plasma, and not the propagation of light waves, so we can use the Darwin approximation.  This removes the displacement current from Maxwell's equations, which become
<a name="equn:dBdt">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">¶</font
><b>B</b>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">¶</font
>t<br /></td><td nowrap="nowrap" align="center">
=<font face="symbol">-</font
><font face="symbol">Ñ</font
>&times;<b>E</b></td></tr></table>
</td><td width="1%">(3.9)</td></tr></table>


<a name="equn:curl_B">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="symbol">Ñ</font
>&times;<b>B</b>=<font face="symbol">m</font
><sub>0</sub><b>J</b></td></tr></table>
</td><td width="1%">(3.10)</td></tr></table>


Ions are accelerated according to the Lorentz force law and we use an equation of motion for the electron fluid:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;d<b>v</b><sub>s</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>dt<br /></td><td nowrap="nowrap" align="center">
=</td><td nowrap="nowrap" align="center">
&nbsp;q<sub>s</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>m<sub>s</sub><br /></td><td nowrap="nowrap" align="center">
(<b>E</b>+<b>v</b><sub>s</sub>&times;<b>B</b>)</td></tr></table>
</td><td width="1%">(3.11)</td></tr></table>


<a name="equn:elec_fluid">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
n<sub>e</sub>m<sub>e</sub></td><td nowrap="nowrap" align="center">
&nbsp;d<b>U</b><sub>e</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>dt<br /></td><td nowrap="nowrap" align="center">
=<font face="symbol">-</font
>n<sub>e</sub>e<b>E</b>+<b>J</b><sub>e</sub>&times;<b>B</b><font face="symbol">-</font
><font face="symbol">Ñ</font
>p<sub>e</sub></td></tr></table>
</td><td width="1%">(3.12)</td></tr></table>


Finally, in order to close the system, we need an equation of state for the electron fluid.  The shock structure is determined by the ion physics, with the electrons providing quasi-neutrality.  It is therefore appropriate to use a simple isothermal equation of state:
<a name="eqn:elec_eos">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
p<sub>e</sub>=n<sub>e</sub>k<sub>B</sub>T<sub>e</sub></td></tr></table>
</td><td width="1%">(3.13)</td></tr></table>



<div class="p"></div>
The observational evidence is that hybrid codes are able to model quasi-perpendicular shocks well.  The hybrid code is the best compromise for our purposes because it allows ion scale physics to be incorporated at manageable computational cost.  In order to achieve this, we must sacrifice the ability to study electron kinetic effects.  Despite not playing a role in determining large scale shock structure, it is possible that such effects might couple with the electron population.  We are, however, able to generate high resolution results for sufficiently long that electron test particle codes can be successfully run in the resulting fields.

<div class="p"></div>
     <h3><a name="tth_sEc3.1.2">
3.1.2</a>&nbsp;&nbsp;Shock generation</h3>

<div class="p"></div>
After selecting a plasma simulation algorithm, we need to determine suitable initial conditions for launching a shock into the simulation box.  In doing this, we should consider whether we are artificially constraining our simulations and whether the properties of the simulation box will provide output which is useful to us.  For example, in our case we want to integrate electron trajectories in our simulation box for a considerable time, starting from upstream of the shock and finishing either upstream or downstream.  We describe two different approaches.  The first requires the shock to be established using an analytic function as a representation of the shock structure.  The second method allows the shock to form in a self-consistent manner by allowing plasma to collide with a boundary.

<div class="p"></div>

<h4>Rankine-Hugoniot conditions</h4>

<div class="p"></div>
It is possible to set up a shock by specifying upstream and downstream conditions using the Rankine-Hugoniot equations [<a href="#leroy++81" name="CITEleroy++81">Leroy <em>et&nbsp;al.</em>, 1981</a>,<a href="#leroy++82" name="CITEleroy++82">Leroy <em>et&nbsp;al.</em>, 1982</a>].  These equations, shown in Section <a href="#sec:RH_relations">1.4.1</a>, describe the shock in terms of conserved quantities.  A thin transition region is introduced in order to link the upstream and downstream and to represent the finite width of the shock transition.  This method, however, has the drawback that it is not self-consistent and that both the downstream distribution and the simulation boundary conditions are prescribed only in terms of the lowest-order ion velocity moments [<a href="#winske+omidi96" name="CITEwinske+omidi96">Winske &amp; Omidi, 1996</a>].  This makes Rankine-Hugoniot initial conditions suitable for MHD codes, but less suitable for kinetic simulations.

<div class="p"></div>

<h4>Dynamic creation</h4>

<div class="p"></div>

<div class="p"></div>
<a name="tth_fIg3.1">
</a> <center><a href="figs/simulation/sim_config.eps">
<img alt="sim_config" src="images/sim_config.gif" border="0"></a>

<center>Figure 3.1: A diagram of the simulation box and initial conditions that we use in order to generate a shock wave.</center>
<a name="fig:sim_config">
</a>
</center>
<div class="p"></div>
Our numerical studies of shocks work by setting up a shock structure and following the paths taken by a number of test particles.  These results can then be used to build up a statistical picture of the variation of the particle distribution function throughout the shock.  The conditions that we use to generate a shock are illustrated in Figure <a href="#fig:sim_config">3.1</a>.  We generate a shock by reflecting homogeneous plasma, moving at constant velocity, off a stationary perfectly conducting barrier.  This is a standard method for launching a shock that is physically simple, but which provides a clean shock once the shock front is clear of the reflecting barrier.  It is also easy to set up this configuration, since the initial magnetic field is guaranteed to have <font face="symbol">Ñ</font
>&#183;<b>B</b> = 0 and the shock parameters may easily be changed by changing the composition and speed of the initial uniform plasma.  The method is self-consistent, and makes no assumptions about the nature of the downstream distribution.

<div class="p"></div>
Our implementation does have some limitations.  The shock is planar, although it is possible to approximate a curved shock by varying <font face="symbol">q</font
><sub><span class="roman">B</span><sub><span class="roman">n</span></sub></sub> along the shock [<a href="#kraussvarban+burgess91" name="CITEkraussvarban+burgess91">Krauss-Varban &amp; Burgess, 1991</a>].  For simplicity we use an upstream plasma that is smooth, so we are neglecting upstream waves and bulk inhomogeneity.  The final limitation, which is intrinsic to this method, is the presence of the downstream barrier.  This prevents us from modelling wave sources there.

<div class="p"></div>
A variation on the stationary barrier is the use of a piston to drive the shock.  This can be achieved by using a simulation box similar to that in Figure <a href="#fig:sim_config">3.1</a>, but keeping the plasma stationary and replacing the reflecting barrier with a moving piston.  In many respects, this is equivalent to a simple frame transformation, but allows the use of a curved piston to produce a curved shock wave.  It also eliminates the need to create plasma at the inflow boundary throughout the course of the simulation.  This can be particularly important in full particle codes, where computational constraints severely limit the number of particles that can be simulated.  The disadvantage to this approach is that, as a result of the frame transformation, the shock leaves the simulation box earlier.  We wish to provide electrons with the maximum possible time to interact with the shock front, and this drawback makes this variation unsuitable.

<div class="p"></div>
 <h2><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;The CAM-CL Hybrid Algorithm</h2>

<div class="p"></div>
The Current Advance Method/Cyclic Leapfrog algorithm [<a href="#matthews94" name="CITEmatthews94">Matthews, 1994</a>] is a hybrid scheme that makes the following additional assumptions: firstly, that the electron fluid is inertialess:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
m<sub>e</sub> = 0</td></tr></table>
</td><td width="1%">(3.14)</td></tr></table>


and secondly, that the electron fluid provides quasi-neutrality:
<a name="equn:quasi-neutrality">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
n<sub>e</sub>e = <font face="symbol">r</font
><sub>c</sub> = </td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><font size="+3"><font face="symbol">å<br />
</font></font><font size="-1">s</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
n<sub>s</sub>q<sub>s</sub></td></tr></table>
</td><td width="1%">(3.15)</td></tr></table>



<div class="p"></div>
Under these approximations, the hybrid equations simplify. We can re-write the expression for an electric field as a state function, so that we can calculate it directly from moments of the ion distribution. Using Equations <a href="#equn:curl_B">3.10</a> and <a href="#equn:elec_fluid">3.12</a> we obtain:
<a name="equn:CAM-CL_e">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>E</b>=</td><td nowrap="nowrap" align="center">
&nbsp;(<font face="symbol">Ñ</font
>&times;<b>B</b>)&times;<b>B</b>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">m</font
><sub>0</sub> <font face="symbol">r</font
><sub>c</sub><br /></td><td nowrap="nowrap" align="center">
<font face="symbol">-</font
> </td><td nowrap="nowrap" align="center">
&nbsp;<b>J</b><sub>i</sub>&times;<b>B</b>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">r</font
><sub>c</sub><br /></td><td nowrap="nowrap" align="center">
<font face="symbol">-</font
></td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">Ñ</font
>p<sub>e</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">r</font
><sub>c</sub><br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.16)</td></tr></table>


where the quantity <font face="symbol">Ñ</font
>p<sub>e</sub> is calculated using the isothermal electron equation of state and the assumption of quasi-neutrality, Equations <a href="#eqn:elec_eos">3.13</a> and <a href="#equn:quasi-neutrality">3.15</a>.

<div class="p"></div>
The CAM-CL algorithm consists of three parts.  The particle push uses a leapfrog method to advance ion velocities and to calculate their trajectories.  The current advance method is used to collect particle moments in the same computational pass through the particle arrays as the particle push.  The cyclic leapfrog method is used once moments have been collected to evolve the fields using a sub-stepping technique that allows many field advances to be conducted per ion time step, thus allowing waves of higher frequencies to be simulated.

<div class="p"></div>

<h4>Particle push</h4>

<div class="p"></div>
Ion positions and velocities are advanced using a leapfrog scheme, which has the advantage of being second order.  This means that the ion position is calculated with a half time step offset to the velocity calculation:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>x</b><sub>s</sub><sup>1/2</sup> = <b>x</b><sub>s</sub><sup><font face="symbol">-</font
>1/2</sup> + <b>v</b><sub>s</sub><sup>0</sup> <font face="symbol">D</font
>t</td></tr></table>
</td><td width="1%">(3.17)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>v</b><sub>s</sub><sup>1</sup> = <b>v</b><sub>s</sub><sup>0</sup> + <font face="symbol">D</font
>t </td><td nowrap="nowrap" align="center">
&nbsp;q<sub>s</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>m<sub>s</sub><br /></td><td nowrap="nowrap" align="center">
(<b>E</b><sup>1/2</sup>(x<sub>s</sub><sup>1/2</sup>)+<b>v</b><sub><b>s</b></sub><sup>1/2</sup>&times;<b>B</b><sup>1/2</sup>( x<sub>s</sub><sup>1/2</sup>))</td></tr></table>
</td><td width="1%">(3.18)</td></tr></table>



<div class="p"></div>
The drawback with this solution is that it is implicit in <b>v</b>, <b>E</b> and <b>B</b>, so we need to be able to estimate <b>v</b><sup>1/2</sup>, <b>E</b><sup>1/2</sup> and <b>B</b><sup>1/2</sup>.  The cyclic leapfrog method is used to advance the magnetic field to <b>B</b><sup>1/2</sup>.  The current advance method is used to calculate the current density <b>J</b> and the charge density <font face="symbol">r</font
><sub>c</sub>, which in conjunction with Equation <a href="#equn:CAM-CL_e">3.16</a> allows us to calculate the state function <b>E</b><sup>1/2</sup>.  Finally, we use a mid-point method to provide an estimate <b>v</b><sup>1/2</sup>:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>v</b><sub>s</sub><sup>1/2</sup> = <b>v</b><sub>s</sub><sup>0</sup> + </td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">D</font
>t
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;q<sub>s</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>m<sub>s</sub><br /></td><td nowrap="nowrap" align="center">
(<b>E</b><sup>1/2</sup>+<b>v</b><sub>s</sub><sup>0</sup>&times;<b>B</b><sup>1/2</sup>)</td></tr></table>
</td><td width="1%">(3.19)</td></tr></table>



<div class="p"></div>
The moment collection in the current advance method requires only <b>x</b><sub>s</sub><sup>1/2</sup>, <b>x</b><sub>s</sub><sup>3/2</sup> and <b>v</b><sub>s</sub><sup>1</sup>.  This is different from many hybrid algorithms, which require a "pre-push" step in order to calculate <b>v</b><sub>s</sub><sup>1/2</sup>.  This has the significant advantage that moment collection can be done in the same computational pass through the particle arrays as the particle push.  According to [<a href="#matthews94" name="CITEmatthews94">Matthews, 1994</a>], this cuts computational time by as much as a half.

<div class="p"></div>

<h4>Current advance method</h4>

<div class="p"></div>
The current advance method is used to find the moments necessary for the calculation of <b>E</b> in a single computational pass of the particle arrays.  The ionic current density <b>J</b><sub>i</sub> is used rather than the fluid velocity in order to facilitate application to a multi-species plasma, since the currents for each ion species may be added directly.  We do not take advantage of this in our simulations as we simulate only a single ion species.  Since we are dealing with ions which are macroparticles, rather than point charges, we distribute the charge using a weighting function <font face="symbol">f</font
> at a position x<sub>j</sub> for a particle at position x<sub>s</sub> and we calculate moments such that:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="symbol">f</font
><sub>sj</sub> = <font face="symbol">f</font
><sub>js</sub> = <font face="symbol">f</font
>(<b>x</b><sub>s</sub>,<b>x</b><sub>j</sub>)</td></tr></table>
</td><td width="1%">(3.20)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="symbol">r</font
><sub>c</sub>(<b>x</b><sub>j</sub>) = </td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><font size="+3"><font face="symbol">å<br />
</font></font><font size="-1">s</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<font face="symbol">f</font
><sub>js</sub> q<sub>s</sub></td></tr></table>
</td><td width="1%">(3.21)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>J</b><sub>i</sub>(<b>x</b><sub>j</sub>) = </td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><font size="+3"><font face="symbol">å<br />
</font></font><font size="-1">s</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<font face="symbol">f</font
><sub>js</sub> q<sub>s</sub> <b>v</b><sub>s</sub></td></tr></table>
</td><td width="1%">(3.22)</td></tr></table>


The same weighting function is used to interpolate fields, so that

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>B</b>(<b>x</b><sub>s</sub>) = </td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><font size="+3"><font face="symbol">å<br />
</font></font><font size="-1">j</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<font face="symbol">f</font
><sub>sj</sub> <b>B</b><sub>j</sub></td></tr></table>
</td><td width="1%">(3.23)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>E</b>(<b>x</b><sub>s</sub>) = </td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><font size="+3"><font face="symbol">å<br />
</font></font><font size="-1">j</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<font face="symbol">f</font
><sub>sj</sub> <b>E</b><sub>j</sub></td></tr></table>
</td><td width="1%">(3.24)</td></tr></table>


We use a bilinear weighting function, such that the weights at the vertices of the grid cell j containing the particle s are given by

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="symbol">f</font
><sub>js</sub> = </td><td align="left" class="cl"><font face="symbol">
æ<br />è
</font></td><td nowrap="nowrap" align="center">
 1 <font face="symbol">-</font
> </td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">|</font
>x<sub>s</sub><font face="symbol">-</font
>x<sub>j</sub><font face="symbol">|</font
>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">D</font
>x<br /></td><td align="left" class="cl"><font face="symbol">
ö<br />ø
</font></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><font face="symbol">
æ<br />è
</font></td><td nowrap="nowrap" align="center">
 1 <font face="symbol">-</font
> </td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">|</font
>y<sub>s</sub><font face="symbol">-</font
>y<sub>j</sub><font face="symbol">|</font
>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">D</font
>y<br /></td><td align="left" class="cl"><font face="symbol">
ö<br />ø
</font></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.25)</td></tr></table>


Some hybrid methods use a "pre-push" of the particles in which an intermediate electric field, <b>E</b><sup>*</sup>, is calculated using <b>E</b><sup>1/2</sup> and the particle velocities are calculated as follows:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>E</b><sup>*</sup> = <b>E</b>(<font face="symbol">r</font
><sub>c</sub><sup>1/2</sup>, J<sub>i</sub><sup>0</sup>, B<sup>1/2</sup>, T<sub>e</sub>)</td></tr></table>
</td><td width="1%">(3.26)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>v</b><sub>s</sub><sup>1/2</sup> = <b>v</b><sub>s</sub><sup>0</sup> + </td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">D</font
>t
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;q<sub>s</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>m<sub>s</sub><br /></td><td nowrap="nowrap" align="center">
(<b>E</b><sup>*</sup>+<b>v</b><sub>s</sub><sup>0</sup>&times;<b>B</b><sup>1/2</sup>)</td></tr></table>
</td><td width="1%">(3.27)</td></tr></table>


Advancing the current density to <b>J</b><sub>i</sub><sup>1/2</sup> and substituting the "pre-push" velocity gives:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>J</b><sub>i</sub><sup>1/2</sup> = </td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><font size="+3"><font face="symbol">å<br />
</font></font><font size="-1">s</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<font face="symbol">f</font
><sub>js</sub><sup>1/2</sup> q<sub>s</sub> <b>v</b><sub>s</sub><sup>1/2</sup></td></tr></table>
</td><td width="1%">(3.28)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
 = </td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><font size="+3"><font face="symbol">å<br />
</font></font><font size="-1">s</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<font face="symbol">f</font
><sub>js</sub><sup>1/2</sup> q<sub>s</sub> <b>v</b><sub>s</sub><sup>0</sup> + </td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><font size="+3"><font face="symbol">å<br />
</font></font><font size="-1">s</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<font face="symbol">f</font
><sub>js</sub><sup>1/2</sup> </td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">D</font
>t
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;q<sub>s</sub><sup>2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>m<sub>s</sub><br /></td><td nowrap="nowrap" align="center">
(<b>E</b><sup>*</sup>+<b>v</b><sup>0</sup>&times;<b>B</b><sup>1/2</sup>)</td></tr></table>
</td><td width="1%">(3.29)</td></tr></table>


The next stage is to re-write this:
<a name="equn:J_from J*">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>J</b><sub>i</sub><sup>1/2</sup> = <b>J</b><sub>i</sub><sup>*</sup> + </td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">D</font
>t
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
(<font face="symbol">L</font
> <b>E</b><sup>*</sup>+<font face="symbol">G</font
>&times;<b>B</b><sup>1/2</sup>)</td></tr></table>
</td><td width="1%">(3.30)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>J</b><sub>i</sub><sup>*</sup> = </td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><font size="+3"><font face="symbol">å<br />
</font></font><font size="-1">s</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<font face="symbol">f</font
><sub>js</sub><sup>1/2</sup> q<sub>s</sub> <b>v</b><sub>s</sub><sup>0</sup></td></tr></table>
</td><td width="1%">(3.31)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="symbol">L</font
> =  </td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><font size="+3"><font face="symbol">å<br />
</font></font><font size="-1">s</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<font face="symbol">f</font
><sub>js</sub><sup>1/2</sup> </td><td nowrap="nowrap" align="center">
&nbsp;q<sub>s</sub><sup>2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>m<sub>s</sub><br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.32)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="symbol">G</font
> = </td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><font size="+3"><font face="symbol">å<br />
</font></font><font size="-1">s</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
<font face="symbol">f</font
><sub>js</sub><sup>1/2</sup> </td><td nowrap="nowrap" align="center">
&nbsp;q<sub>s</sub><sup>2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>m<sub>s</sub><br /></td><td nowrap="nowrap" align="center">
<b>v</b><sub><b>s</b></sub><sup>0</sup></td></tr></table>
</td><td width="1%">(3.33)</td></tr></table>



<div class="p"></div>
The key to the current advance method is to recognise <b>J</b><sub>i</sub><sup>*</sup> as the "free-streaming" ionic current density. This represents the current density calculated at time step 1/2 under the approximation that no acceleration occurs (the ions are "free-streaming"). This has the advantage that <b>J</b><sub>i</sub><sup>*</sup>, along with <font face="symbol">L</font
> and <font face="symbol">G</font
> can be computed in a single pass through the particle arrays without the need for a "pre-push" step.

<div class="p"></div>

<h4>Cyclic leapfrog</h4>

<div class="p"></div>
The cyclic leapfrog scheme allows the fields to evolve for many sub-steps between particle time steps. This is useful since the evolution of magnetic fields can occur at higher frequencies than that of particles [<a href="#teresawa++86" name="CITEteresawa++86">Teresawa <em>et&nbsp;al.</em>, 1986</a>]. The electric field is evaluated according to Equation <a href="#equn:CAM-CL_e">3.16</a> using the previously collected moments and the magnetic field is advanced using a time sub-step h, with N sub-steps per particle move, such that

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>B</b><sup>p</sup> = <b>B</b>(t<sup>0</sup>+ph)</td></tr></table>
</td><td width="1%">(3.34)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>E</b><sup>p</sup> = <b>E</b>(<font face="symbol">r</font
><sub>c</sub><sup>1/2</sup>, <b>J</b><sub>i</sub><sup>1/2</sup>, <b>B</b><sup>p</sup>, T<sub>e</sub>)</td></tr></table>
</td><td width="1%">(3.35)</td></tr></table>



<div class="p"></div>
The magnetic field is then evolved using a leapfrog method according to Equation <a href="#equn:dBdt">3.9</a>, with leapfrogging sub-steps p = 1, ..., N<font face="symbol">-</font
>1:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>B</b><sup>1</sup> = <b>B</b><sup>0</sup> <font face="symbol">-</font
> h <font face="symbol">Ñ</font
>&times;<b>E</b><sup>0</sup></td></tr></table>
</td><td width="1%">(3.36)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>B</b><sup>2</sup> = <b>B</b><sup>0</sup> <font face="symbol">-</font
> 2h <font face="symbol">Ñ</font
>&times;<b>E</b><sup>1</sup></td></tr></table>
</td><td width="1%">(3.37)</td></tr></table>



<div class="p"></div>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>B</b><sup>p+1</sup> = <b>B</b><sup>p<font face="symbol">-</font
>1</sup> <font face="symbol">-</font
> 2h <font face="symbol">Ñ</font
>&times;<b>E</b><sup>p</sup></td></tr></table>
</td><td width="1%">(3.38)</td></tr></table>



<div class="p"></div>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>B</b><sup>N</sup> = <b>B</b><sup>N<font face="symbol">-</font
>2</sup> <font face="symbol">-</font
> 2h <font face="symbol">Ñ</font
>&times;<b>E</b><sup>N<font face="symbol">-</font
>1</sup></td></tr></table>
</td><td width="1%">(3.39)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>B</b><sup>N*</sup> = <b>B</b><sup>N<font face="symbol">-</font
>1</sup> <font face="symbol">-</font
> h <font face="symbol">Ñ</font
>&times;<b>E</b><sup>N</sup></td></tr></table>
</td><td width="1%">(3.40)</td></tr></table>



<div class="p"></div>
The final step, to calculate <b>B</b>(t<sup>0</sup>+Nh), may either be an averaging of <b>B</b><sup>N</sup> and <b>B</b><sup>N*</sup> or an extension of the cycle using 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>B</b>(t<sup>0</sup>+Nh) = <b>B</b><sup>N*</sup> <font face="symbol">-</font
> h <font face="symbol">Ñ</font
>&times;<b>E</b>(<b>B</b><sup>N*</sup>)</td></tr></table>
</td><td width="1%">(3.41)</td></tr></table>



<div class="p"></div>

<h4>Implementation</h4>

<div class="p"></div>
The electric field is computed on a grid that is interlaced with the grids for all other quantities, being offset by half a grid cell. This means that spatial derivatives can be calculated using bilinear finite differencing, of the form

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">¶</font
>f
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">¶</font
>x<br /></td><td nowrap="nowrap" align="center">
(x<sub>i+1/2</sub>,y<sub>j+1/2</sub>) = </td><td nowrap="nowrap" align="center">
&nbsp;1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2 <font face="symbol">d</font
>x<br /></td><td nowrap="nowrap" align="center">
(f<sub>i+1,j+1</sub> + f<sub>i+1,j</sub> <font face="symbol">-</font
> f<sub>i,j+1</sub> <font face="symbol">-</font
> f<sub>i,j</sub>)</td></tr></table>
</td><td width="1%">(3.42)</td></tr></table>


where the grid cell positions are labelled as in Figure <a href="#fig:grid_cell">3.3</a>.  The interlaced grids allow us to determine <font face="symbol">Ñ</font
>&times;<b>E</b> for the calculation of <b>B</b>, in addition to <font face="symbol">Ñ</font
>&times;<b>B</b> and <font face="symbol">Ñ</font
>p<sub>e</sub> for the calculation of <b>E</b>.  Other quantities may be interpolated between the grids using bilinear weights, such that 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
f(x<sub>i+1/2</sub>,y<sub>j+1/2</sub>) = </td><td nowrap="nowrap" align="center">
&nbsp;1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4<br /></td><td nowrap="nowrap" align="center">
(f<sub>i+1,j+1</sub> + f<sub>i+1,j</sub> + f<sub>i,j+1</sub> + f<sub>i,j</sub>)</td></tr></table>
</td><td width="1%">(3.43)</td></tr></table>



<div class="p"></div>
Units are defined in terms of a reference plasma of protons (with proton mass m<sub>p</sub> and charge e) that has the same mass density, <font face="symbol">r</font
><sub>0</sub>, as the simulation plasma. Quantities are normalised according to the initial values of the plasma parameters, which in our simulations correspond to their values in the plasma upstream of the shock.  The normalisation is as follows:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;m<sub>p</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>e<br /></td><td nowrap="nowrap" align="center">
 = 1, <font face="symbol">m</font
><sub>0</sub> = 1</td></tr></table>
</td><td width="1%">(3.44)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
v<sub>0</sub> = v<sub>A</sub></td></tr></table>
</td><td width="1%">(3.45)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
B<sub>0</sub> = B</td></tr></table>
</td><td width="1%">(3.46)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
E<sub>0</sub> = v<sub>A</sub> B<sub>0</sub></td></tr></table>
</td><td width="1%">(3.47)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="symbol">W</font
><sub>i</sub><sup><font face="symbol">-</font
>1</sup> = </td><td nowrap="nowrap" align="center">
&nbsp;e B<sub>0</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>m<sub>p</sub><br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.48)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
t<sub>0</sub> = <font face="symbol">W</font
><sub>i</sub><sup><font face="symbol">-</font
>1</sup></td></tr></table>
</td><td width="1%">(3.49)</td></tr></table>


where unit quantities are denoted by the subscript 0.

<div class="p"></div>
The electron and ion temperatures are both specified in the initial conditions.  The plasma beta is the ratio of thermal to magnetic pressures.  For electrons,

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="symbol">b</font
><sub>e</sub> = </td><td nowrap="nowrap" align="center">
&nbsp;2 p<sub>e</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>B<sup>2</sup><br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.50)</td></tr></table>


Ions are initially started with a drifting Maxwellian velocity distribution, with thermal velocity v<sub>th</sub>.  We define a temperature for ions with components perpendicular and parallel to the magnetic field, such that

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
T<sub>s <font face="symbol">^</font
></sub> = </td><td nowrap="nowrap" align="center">
&nbsp;(v<sub>th <font face="symbol">^</font
></sub><sup>2</sup>)<sub>s</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.51)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
T<sub>s <font face="symbol">||</font
></sub> = </td><td nowrap="nowrap" align="center">
&nbsp;(v<sub>th <font face="symbol">||</font
></sub><sup>2</sup>)<sub>s</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.52)</td></tr></table>


So, initially, 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="symbol">b</font
><sub>s0</sub> = </td><td nowrap="nowrap" align="center">
&nbsp;T<sub>s0 <font face="symbol">^</font
></sub> + T<sub>s0 <font face="symbol">||</font
></sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.53)</td></tr></table>


It is therefore possible to establish a temperature anisotropy for the ions, such that T<sub><font face="symbol">||</font
></sub>  <font face="symbol">¹</font
> T<sub><font face="symbol">^</font
></sub>, although we have not used this aspect of the code.

<div class="p"></div>
The actual implementation of the CAM-CL algorithm by <a href="#matthews94" name="CITEmatthews94">Matthews [1994]</a> determines quantities in the following three stages.  In the first step, <b>B</b><sup>0</sup> is advanced to <b>B</b><sup>1/2</sup> and <b>J</b><sub>i</sub><sup>1/2</sup> is calculated from the free-streaming current density using Equation <a href="#equn:J_from J*">3.29</a>, so that <b>E</b><sup>1/2</sup> can be evaluated.

<div class="p"></div>
The second step is the most complex, since it involves the particle push and collection of moments.  <b>v</b><sup>0</sup> is advanced to <b>v</b><sup>1</sup> and <b>x</b><sup>1/2</sup> is advanced to <b>x</b><sup>3/2</sup>.  All moments are collected in the same computational pass through the particle arrays using <b>v</b><sup>1</sup> and <b>x</b><sup>3/2</sup>.  A current moment is also collected using <b>v</b><sup>1</sup> and <b>x</b><sup>1/2</sup> in order to determine <b>J</b><sub>i</sub><sup>1</sup>.  An equivalent density moment is required at <b>x</b><sup>1/2</sup>, but this are not collected since the moments from the previous time step can be used.

<div class="p"></div>
The third step consists of calculating <font face="symbol">r</font
><sub>c</sub><sup>1</sup> and <b>J</b><sub>i</sub><sup>1</sup> by averaging their values at time steps 1/2 and 3/2.  <b>B</b><sup>1/2</sup> can then be advanced to <b>B</b><sup>1</sup>.  At this point diagnostics can be saved before the simulation continues with the first step.

<div class="p"></div>
The interleaving of time steps, such that <b>v</b> is determined at time steps 0 and 1, whilst <b>x</b> is determined at time steps 1/2 and 3/2, means that the simulation  must use an initial step to advance <b>x</b>, and then the necessary moments, by half a time step.  A similar procedure must be followed at the end of the simulation, or when diagnostics are saved to disk, so that <b>x</b><sup>3/2</sup> can be retreated half a time step and the density and flow can be calculated with positions that are consistent with the velocity, <b>v</b><sup>1</sup>.

<div class="p"></div>
 <h2><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;Test Particle Schemes</h2>

<div class="p"></div>
We investigate electron behaviour by following the trajectories of test particles. We follow <a href="#kraussvarban++89" name="CITEkraussvarban++89">Krauss-Varban <em>et&nbsp;al.</em> [1989]</a> by using a high order integration scheme. Our implementation of the code is relativistic and, in test situations, conserves both energy and perpendicular magnetic moment well. None of these schemes do any sort of field interpolation themselves and fields are assumed to be constant, which means that a separate field interpolation scheme will also be required.

<div class="p"></div>
We compare two fourth-order integration schemes for the particle move: a Runge-Kutta method and an implicit leapfrog scheme based on <a href="#thomsen68" name="CITEthomsen68">Thomsen, [1968</a>]. We conduct performance comparisons by examining the conservation of energy and magnetic moment, <font face="symbol">m</font
>, in a magnetic trap.

<div class="p"></div>

<h4>Runge-Kutta</h4>

<div class="p"></div>
Conventionally, a fourth order Runge-Kutta method provides a good compromise between speed and accuracy. This solver has the advantage of not requiring <b>v</b> to be known explicitly as a function of <b>x</b>. We use the following method for integrating the particle trajectories [<a href="#davis+polonsky65" name="CITEdavis+polonsky65">Davis &amp; Polonsky, 1965</a>,<a href="#vesely94" name="CITEvesely94">Vesely, 1994</a>]:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>x</b><sup>1</sup> = <b>x</b><sup>0</sup>+<b>v</b><sup>0</sup> <font face="symbol">D</font
>t + </td><td nowrap="nowrap" align="center">
&nbsp;(<font face="symbol">D</font
>t)<sup>2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>6<br /></td><td nowrap="nowrap" align="center">
(<b>b</b><sup>1</sup>+<b>b</b><sup>2</sup>+<b>b</b><sup>3</sup>)</td></tr></table>
</td><td width="1%">(3.54)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>v</b><sup>1</sup> = <b>v</b><sup>0</sup>+</td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">D</font
>t
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>6<br /></td><td nowrap="nowrap" align="center">
(<b>b</b><sup>1</sup>+2<b>b</b><sup>2</sup>+2<b>b</b><sup>3</sup>+<b>b</b><sup>4</sup>)</td></tr></table>
</td><td width="1%">(3.55)</td></tr></table>


where

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>b</b><sup>1</sup> = <b>E</b><sup>0</sup> + <b>v</b><sup>0</sup> &times;<b>B</b><sup>0</sup></td></tr></table>
</td><td width="1%">(3.56)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>b</b><sup>2</sup> = <b>E</b><sup>0</sup> + (<b>v</b><sup>0</sup> + </td><td nowrap="nowrap" align="center">
&nbsp;<b>b</b><sup>1</sup><font face="symbol">D</font
>t
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
) &times;<b>B</b><sup>0</sup></td></tr></table>
</td><td width="1%">(3.57)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>b</b><sup>3</sup> = <b>E</b><sup>0</sup> + (<b>v</b><sup>0</sup> + </td><td nowrap="nowrap" align="center">
&nbsp;<b>b</b><sup>2</sup><font face="symbol">D</font
>t
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
) &times;<b>B</b><sup>0</sup></td></tr></table>
</td><td width="1%">(3.58)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>b</b><sup>4</sup> = <b>E</b><sup>0</sup> + (<b>v</b><sup>0</sup> + <b>b</b><sup>3</sup><font face="symbol">D</font
>t) &times;<b>B</b><sup>0</sup></td></tr></table>
</td><td width="1%">(3.59)</td></tr></table>



<div class="p"></div>

<h4>Implicit Leapfrog</h4>

<div class="p"></div>
An alternative method is a fourth order implicit leapfrog or "Thomsen" solver.  This code is an adaptation of a Fortran version used in <a href="#kraussvarban++89" name="CITEkraussvarban++89">Krauss-Varban <em>et&nbsp;al.</em> [1989]</a>,<a href="#kraussvarban+burgess91" name="CITEkraussvarban+burgess91">Krauss-Varban &amp; Burgess [1991]</a> and <a href="#kraussvarban94" name="CITEkraussvarban94">Krauss-Varban [1994]</a> and is based on a description by <a href="#thomsen68" name="CITEthomsen68">Thomsen, [1968</a>].  This solver combines a leapfrog method for moving the particles with an implicit method for calculating velocities.  We will later show that the implicit leapfrog solver has superior conservation properties for both energy and magnetic moment when compared to a Runge-Kutta solver.

<div class="p"></div>
The leapfrog scheme starts by pre-computing a position for use in the velocity determination,

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>x</b><sup>1/2</sup> = <b>x</b><sup>0</sup>+</td><td nowrap="nowrap" align="center">
&nbsp;<b>v</b><sup><font face="symbol">-</font
>1/2</sup> <font face="symbol">D</font
>t
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.60)</td></tr></table>


The velocity, <b>v</b> is evolved from <b>v</b><sup><font face="symbol">-</font
>1/2</sup> to <b>v</b><sup>1/2</sup> using an implicit method on the <b>E</b> and <b>B</b> fields. Implicit methods require the inversion of a matrix and are therefore more complicated to implement.  We use the numerical method for solving a set of simultaneous first-order linear equations described by <a href="#thomsen68" name="CITEthomsen68">Thomsen, [1968</a>]. For an equation

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;d<b>x</b>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>dt<br /></td><td nowrap="nowrap" align="center">
 = <font face="helvetica"><b>A</b></font><b>x</b>+<font face="helvetica"><b>B</b></font><b>u</b>(t)</td></tr></table>
</td><td width="1%">(3.61)</td></tr></table>


the solution with a truncation error O(h<sup>5</sup>), where h is the step size, is

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>x</b>(h) = <font face="helvetica"><b>M</b></font> <b>y</b></td></tr></table>
</td><td width="1%">(3.62)</td></tr></table>


where

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="helvetica"><b>M</b></font> = </td><td align="left" class="cl"><font face="symbol">
æ<br />è
</font></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">I</font></font><font face="symbol">-</font
></td><td nowrap="nowrap" align="center">
&nbsp;h
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">A</font></font>+</td><td nowrap="nowrap" align="center">
&nbsp;h<sup>2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>12<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">A</font></font><sup>2</sup></td><td align="left" class="cl"><font face="symbol">
ö<br />ø
</font></td><td nowrap="nowrap" align="center">
<font size="-1"><font face="symbol">-</font
>1</font><!--sup
--><br /><br />
<font size="-1"></font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.63)</td></tr></table>


and

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>y</b> = </td><td align="left" class="cl"><font face="symbol">
æ<br />è
</font></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">I</font></font> +</td><td nowrap="nowrap" align="center">
&nbsp;h
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">A</font></font>+</td><td nowrap="nowrap" align="center">
&nbsp;h<sup>2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>12<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">A</font></font><sup>2</sup></td><td align="left" class="cl"><font face="symbol">
ö<br />ø
</font></td><td nowrap="nowrap" align="center">
<b>x</b>(0) + </td><td align="left" class="cl"><font face="symbol">
æ<br />è
</font></td><td nowrap="nowrap" align="center">
&nbsp;1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">I</font></font>+</td><td nowrap="nowrap" align="center">
&nbsp;h
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>12<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">A</font></font></td><td align="left" class="cl"><font face="symbol">
ö<br />ø
</font></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">B</font></font><b>u</b>(0)h + </td><td align="left" class="cl"><font face="symbol">
æ<br />è
</font></td><td nowrap="nowrap" align="center">
&nbsp;1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">I</font></font><font face="symbol">-</font
></td><td nowrap="nowrap" align="center">
&nbsp;h
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>12<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">A</font></font></td><td align="left" class="cl"><font face="symbol">
ö<br />ø
</font></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">B</font></font><b>u</b>(h)h +</td><td nowrap="nowrap" align="center">
&nbsp;h<sup>2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>12<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">B</font></font></td><td nowrap="nowrap" align="center">
<div class="comp"><font face="symbol">×</font
><br /></div>
<div class="norm"><b>u</b><br /></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
(0) <font face="symbol">-</font
> </td><td nowrap="nowrap" align="center">
&nbsp;h<sup>2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>12<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">B</font></font></td><td nowrap="nowrap" align="center">
<div class="comp"><font face="symbol">×</font
><br /></div>
<div class="norm"><b>u</b><br /></div>
<div class="comb">&nbsp;</div>
</td><td nowrap="nowrap" align="center">
(h) + </td><td nowrap="nowrap" align="center">
&nbsp;1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>720<br /></td><td nowrap="nowrap" align="center">
<font face="symbol">d</font
><sup>5</sup> x </td><td align="left" class="cl"><font face="symbol">
æ<br />è
</font></td><td nowrap="nowrap" align="center">
&nbsp;h
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td align="left" class="cl"><font face="symbol">
ö<br />ø
</font></td><td nowrap="nowrap" align="center">
<font face="symbol">-</font
> ...</td></tr></table>
</td><td width="1%">(3.64)</td></tr></table>



<div class="p"></div>
The governing equation is the Lorentz force equation, with a normalized charge to mass ratio, so that
<a name="equn:lorentz_force_law">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;d<b>v</b>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>dt<br /></td><td nowrap="nowrap" align="center">
 = <b>E</b> + <b>v</b> &times;<b>B</b></td></tr></table>
</td><td width="1%">(3.65)</td></tr></table>



<div class="p"></div>
The fields in our hybrid simulations vary on ion scales, so we may assume that there is no significant temporal or spatial variation over time scales of order the time step h and length scales of order the grid spacing <font face="symbol">D</font
>x. We can write Equation <a href="#equn:lorentz_force_law">3.60</a> in the form:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;d<b>v</b>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>dt<br /></td><td nowrap="nowrap" align="center">
 = <font face="helvetica"><font face="helvetica">A</font></font><b>v</b>+<font face="helvetica"><font face="helvetica">I</font></font><b>E</b></td></tr></table>
</td><td width="1%">(3.66)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="helvetica"><b>A</b></font> = </td><td align="left" class="cl"><font face="symbol">
æ<br />ç<br />ç<br />
ç<br />è
</font> </td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
0 </td></tr></table></td><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
B<sub>z</sub> </td></tr></table></td><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<font face="symbol">-</font
>B<sub>y</sub> </td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<font face="symbol">-</font
>B<sub>z</sub> </td></tr></table></td><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
0 </td></tr></table></td><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
B<sub>x</sub> </td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
B<sub>y</sub> </td></tr></table></td><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<font face="symbol">-</font
>B<sub>x</sub> </td></tr></table></td><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
0 </td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
 </td><td align="left" class="cl"><font face="symbol">
ö<br />÷<br />÷<br />
÷<br />ø
</font></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.67)</td></tr></table>



<div class="p"></div>
where [(<b>E</b>)\dot] = 0. This produces a finite difference equation:

<div class="p"></div>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>v</b><sup>1/2</sup> = </td><td align="left" class="cl"><font face="symbol">
æ<br />è
</font></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">I</font></font><font face="symbol">-</font
></td><td nowrap="nowrap" align="center">
&nbsp;h
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">A</font></font>+</td><td nowrap="nowrap" align="center">
&nbsp;h<sup>2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>12<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">A</font></font><sup>2</sup></td><td align="left" class="cl"><font face="symbol">
ö<br />ø
</font></td><td nowrap="nowrap" align="center">
<font size="-1"><font face="symbol">-</font
>1</font><!--sup
--><br /><br />
<font size="-1"></font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><font face="symbol">
é<br />ë
</font></td><td align="left" class="cl"><font face="symbol">
æ<br />è
</font></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">I</font></font> +</td><td nowrap="nowrap" align="center">
&nbsp;h
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">A</font></font>+</td><td nowrap="nowrap" align="center">
&nbsp;h<sup>2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>12<br /></td><td nowrap="nowrap" align="center">
<font face="helvetica"><font face="helvetica">A</font></font><sup>2</sup></td><td align="left" class="cl"><font face="symbol">
ö<br />ø
</font></td><td nowrap="nowrap" align="center">
<b>v</b><sup><font face="symbol">-</font
>1/2</sup> + <b>E</b>h </td><td align="left" class="cl"><font face="symbol">
ù<br />û
</font></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.68)</td></tr></table>



<div class="p"></div>
We then finish the scheme by carrying out the second half of the x integration,

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>x</b><sup>1</sup> = <b>x</b><sup>1/2</sup>+<b>v</b><sup>1/2</sup> <font face="symbol">D</font
>t</td></tr></table>
</td><td width="1%">(3.69)</td></tr></table>



<div class="p"></div>

<h4>Scheme comparison</h4>

<div class="p"></div>
<a name="sec:elec_scheme_compare">
</a>We compare the two test particle solvers described above by setting up a test simulation in which a population of particles is trapped within a magnetic bottle.  A simple and effective method for constructing such a magnetic trap is to align two dipole fields so that particles can mirror between the poles. We use the following field for a single dipole:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>B</b>(x,y,z) = </td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">m</font
><sub>D</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>r<sup>5</sup><br /></td><td nowrap="nowrap" align="center">
(xz,yz,</td><td nowrap="nowrap" align="center">
&nbsp;2r<sup>2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>3<br /></td><td nowrap="nowrap" align="center">
<font face="symbol">-</font
>(x<sup>2</sup>+y<sup>2</sup>))</td></tr></table>
</td><td width="1%">(3.70)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<b>E</b>=<b>0</b></td></tr></table>
</td><td width="1%">(3.71)</td></tr></table>


where

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
r<sup>2</sup>=x<sup>2</sup>+y<sup>2</sup>+z<sup>2</sup></td></tr></table>
</td><td width="1%">(3.72)</td></tr></table>


and <font face="symbol">m</font
><sub>D</sub> is the dipole strength.

<div class="p"></div>
The field configuration is such that two dipoles, both of strength <font face="symbol">m</font
><sub>D</sub>=18 B<sub>0</sub>, are aligned along the z-axis, one at z=2 v<sub>A</sub> <font face="symbol">W</font
><sub>i</sub><sup><font face="symbol">-</font
>1</sup> and one at z=<font face="symbol">-</font
>4 v<sub>A</sub> <font face="symbol">W</font
><sub>i</sub><sup><font face="symbol">-</font
>1</sup>. This provides a useful environment in which to test the numerical schemes' ability to work with inhomogeneous fields. The field configuration has no electric field, so an ideal integrator will conserve particle energy.  The field strength on the z-axis at z=1 v<sub>A</sub> <font face="symbol">W</font
><sub>i</sub><sup><font face="symbol">-</font
>1</sup> is B=12 B<sub>0</sub>, so the field gradient is comparable with that seen in the shock ramp.

<div class="p"></div>
We test our particle solvers by releasing a population of electrons with gyrocentres at the origin, where the field strength is B=1.6875 B<sub>0</sub>.  The electrons have a single energy of 0.1 keV such that the distribution in velocity space is a uniform spherical shell.  This gives initial magnetic moments in the range <font face="symbol">m</font
> <font face="symbol">£</font
> 0.0593 <span class="roman">eV</span> B<sub>0</sub><sup><font face="symbol">-</font
>1</sup>.  The number of particles simulated was 105,000, which is similar to the number used in the simulations described in Chapter <a href="#chap:elec_pop">5</a>.  In addition, our tests used an integration time of 3000 <font face="symbol">W</font
><sub>i</sub><sup><font face="symbol">-</font
>1</sup>, which is equal to the duration of the simulations.

<div class="p"></div>
The maximum magnetic field increase felt by electrons in our simulations is about B<sub><span class="roman">max</span></sub>  <font face="symbol">»</font
> 10 B<sub><span class="roman">init</span></sub>.  The only electrons in our test simulation to reflect in fields larger than this have low magnetic moments of <font face="symbol">m</font
> &lt;~0.006 <span class="roman">eV</span> B<sub>0</sub><sup><font face="symbol">-</font
>1</sup>.  We need our test particle code to conserve energy and magnetic moment for electrons with <font face="symbol">m</font
> above this range.

<div class="p"></div>
Figure <a href="#fig:elec_int_compare">3.2</a> compares the energy and magnetic moment conservation properties of the fourth order Runge-Kutta method and implicit leapfrog scheme.  This is done by plotting the final value of the energy and magnetic moment against the initial value of the magnetic moment.  The fourth order Runge-Kutta scheme is shown with <font face="symbol">D</font
>t = 0.1 <font face="symbol">W</font
><sub>e</sub><sup><font face="symbol">-</font
>1</sup> and <font face="symbol">D</font
>t = 0.02 <font face="symbol">W</font
><sub>e</sub><sup><font face="symbol">-</font
>1</sup>.  The implicit leapfrog scheme, whose computational speed is comparable with the Runge-Kutta scheme, is shown with <font face="symbol">D</font
>t = 0.1 <font face="symbol">W</font
><sub>e</sub><sup><font face="symbol">-</font
>1</sup>.

<div class="p"></div>
The Runge-Kutta scheme with <font face="symbol">D</font
>t = 0.1 <font face="symbol">W</font
><sub>e</sub><sup><font face="symbol">-</font
>1</sup> has poor <font face="symbol">m</font
> and energy conservation for all values of <font face="symbol">m</font
><sub><span class="roman">init</span></sub> and fails to conserve both by more than a factor of two for <font face="symbol">m</font
><sub><span class="roman">init</span></sub>  <font face="symbol">£</font
> 0.04 <span class="roman">eV</span> B<sub>0</sub><sup><font face="symbol">-</font
>1</sup>.  With <font face="symbol">D</font
>t = 0.02 <font face="symbol">W</font
><sub>e</sub><sup><font face="symbol">-</font
>1</sup>, the Runge-Kutta scheme performs better, conserving <font face="symbol">m</font
> and energy to within a few percent when <font face="symbol">m</font
><sub><span class="roman">init</span></sub>  <font face="symbol">³</font
> 0.01 <span class="roman">eV</span> B<sub>0</sub><sup><font face="symbol">-</font
>1</sup>.  Below this value, however, the conservation is very poor and the final values of <font face="symbol">m</font
> and energy drop to around zero.  This is likely to affect the electrons in our simulations that experience the greatest field changes.  The implicit leapfrog scheme with <font face="symbol">D</font
>t = 0.1 <font face="symbol">W</font
><sub>e</sub> also conserves <font face="symbol">m</font
> and energy to within a few percent, but for a larger range of  <font face="symbol">m</font
><sub><span class="roman">init</span></sub>  <font face="symbol">³</font
> 3 &times;10<sup><font face="symbol">-</font
>4</sup> <span class="roman">eV</span> B<sub>0</sub><sup><font face="symbol">-</font
>1</sup>.  At magnetic moments below these thresholds, the test particles in all the schemes encounter very high field gradients that cause numerical errors.  According to our results, this would be problematic for the Runge-Kutta scheme.  None of the electrons in our simulation are likely to experience field gradients that are sufficiently large for this to affect the implicit leapfrog scheme.

<div class="p"></div>
The Fourth Order Runge-Kutta method performs surprisingly poorly.  It suffers from a systematic energy loss aggregated over a large number of time steps.    The implicit leapfrog scheme, shown with <font face="symbol">D</font
>t = 0.1 <font face="symbol">W</font
><sub>e</sub>, clearly has superior conservation properties for both energy and magnetic moment.  This is the electron trajectory integrator that we chose for our simulations, for which we used a time step <font face="symbol">D</font
>t = 0.05 <font face="symbol">W</font
><sub>e</sub><sup><font face="symbol">-</font
>1</sup>.  There is evidence that varying the electron time step has an effect on our simulation results and the reasons for choosing <font face="symbol">D</font
>t = 0.05 <font face="symbol">W</font
><sub>e</sub><sup><font face="symbol">-</font
>1</sup> are given in Section <a href="#sec:elec_spec_num_dep">6.1.1</a>.

<div class="p"></div>

<div class="p"></div>
<a name="tth_fIg3.2">
</a> <center><a href="figs/simulation/energy_dipole.eps">
<img alt="energy_dipole" src="images/energy_dipole.gif" border="0"></a>

<div class="p"></div>
<a href="figs/simulation/mu_dipole.eps">
<img alt="mu_dipole" src="images/mu_dipole.gif" border="0"></a>

<div class="p"></div>
<center>Figure 3.2: Graphs illustrating the conservation properties of electron trajectory integrators. The intensity of the boxes represents particle number density on a logarithmic scale.  The fourth order Runge-Kutta scheme is shown with <font face="symbol">D</font
>t = 0.1 <font face="symbol">W</font
><sub>e</sub><sup><font face="symbol">-</font
>1</sup> (red) and <font face="symbol">D</font
>t = 0.02 <font face="symbol">W</font
><sub>e</sub><sup><font face="symbol">-</font
>1</sup> (green).  The implicit leapfrog scheme is shown with <font face="symbol">D</font
>t = 0.1 <font face="symbol">W</font
><sub>e</sub><sup><font face="symbol">-</font
>1</sup> (blue).</center>
<a name="fig:elec_int_compare">
</a>
</center>
<div class="p"></div>
 <h2><a name="tth_sEc3.4">
3.4</a>&nbsp;&nbsp;Field Interpolation</h2>

<div class="p"></div>
<a href="#kraussvarban++89" name="CITEkraussvarban++89">Krauss-Varban <em>et&nbsp;al.</em> [1989]</a> found that high frequency fluctuations in the electric field were a significant cause of scattering in electrons' v<sub><font face="symbol">^</font
></sub>.  In addition, we found that our electron integrator had stability problems at the shock front when the spatial grid spacing was too large.  It therefore seems that the choice of field interpolation algorithm is important in studying test particle trajectories.  We discuss a selection of interpolation schemes here, the algorithms for which are based on the discussion given in <a href="#press++92" name="CITEpress++92">Press <em>et&nbsp;al.</em>, [1992</a>]. 

<div class="p"></div>

<h4>1-D interpolation</h4>

<div class="p"></div>
A 1-D interpolation is suitable for the temporal interpolation of our field data. If time, t, lies between time steps t<sup>0</sup> and t<sup>1</sup>, which are separated by a time <font face="symbol">D</font
>t, then we define the following:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
A = </td><td nowrap="nowrap" align="center">
&nbsp;t<sup>1</sup> <font face="symbol">-</font
> t 
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">D</font
>t<br /></td><td nowrap="nowrap" align="center">
,&nbsp;B = (1<font face="symbol">-</font
>A) = </td><td nowrap="nowrap" align="center">
&nbsp;t <font face="symbol">-</font
> t<sup>0</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">D</font
>t<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.73)</td></tr></table>



<div class="p"></div>
Bilinear interpolation is a simple linear interpolation method that takes the form
<a name="equn:bilinear_1d">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
f(t) = A f<sup>0</sup> + B f<sup>1</sup></td></tr></table>
</td><td width="1%">(3.74)</td></tr></table>



<div class="p"></div>
A more sophisticated method of interpolation is the cubic spline. This allows us to interpolate the function in such a way that its first derivative is smooth and hence its second derivative is continuous. To see how this is achieved, let us first consider the case where we know the function's second derivative, f". We then add a correction term to Equation <a href="#equn:bilinear_1d">3.69</a>
<a name="equn:bicubic_1d">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
f(t) = A f<sup>0</sup> + B f<sup>1</sup> + C f<sup>0"</sup> + D f<sup>1"</sup></td></tr></table>
</td><td width="1%">(3.75)</td></tr></table>


Under the condition that f(t) must tend to the prescribed values of f and f" at t<sup>0</sup> and t<sup>1</sup>, the lowest order solution for C and D is

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
C = </td><td nowrap="nowrap" align="center">
&nbsp;1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>6<br /></td><td nowrap="nowrap" align="center">
(A<sup>3</sup><font face="symbol">-</font
>A) <font face="symbol">D</font
>t<sup>2</sup>,&nbsp;B = </td><td nowrap="nowrap" align="center">
&nbsp;1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>6<br /></td><td nowrap="nowrap" align="center">
(B<sup>3</sup><font face="symbol">-</font
>B) <font face="symbol">D</font
>t<sup>2</sup></td></tr></table>
</td><td width="1%">(3.76)</td></tr></table>


By differentiating Equation <a href="#equn:bicubic_1d">3.70</a> and requiring this derivative to be continuous at the cell boundaries, we obtain a restriction on f":
<a name="equn:spline_derivs">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
f<sup><font face="symbol">-</font
>1"</sup> + 4f<sup>0"</sup> + f<sup>1"</sup> = 0</td></tr></table>
</td><td width="1%">(3.77)</td></tr></table>


The system is closed by specifying f" at the boundaries. These values are usually either calculated or set to zero to give a "natural" spline. This system of equations is implicit, but Equation <a href="#equn:spline_derivs">3.72</a> is also tridiagonal, so the system can be solved at reasonable computational expense in O(N) operations, where N is the number of time steps across which the interpolation is made.

<div class="p"></div>
Our field data vary slowly over time. Field time steps in a hybrid code are based on ion time scales, which differ from electron time scales by the order of the mass ratio m<sub>p</sub>/m<sub>e</sub>, which is around 2000.  A typical electron has a very high speed with respect to these field time steps, so it will travel across a number of spatial grid cells in a single field time step.  This means that a high accuracy temporal interpolation is not required for the test particle code.  We have therefore used a bilinear method for interpolation in time as the additional accuracy of the spline method is not worth the considerable trade-off in complexity and computational time.

<div class="p"></div>

<h4>2-D interpolation</h4>

<div class="p"></div>

<div class="p"></div>
<a name="tth_fIg3.3">
</a> <center><a href="figs/simulation/grid_cell.eps">
<img alt="grid_cell" src="images/grid_cell.gif" border="0"></a>

<center>Figure 3.3: Labelling of quantities within a grid cell.</center>
<a name="fig:grid_cell">
</a>
</center>
<div class="p"></div>
A 2-D interpolation is required for spatial interpolation of the fields. If (x<sub>i</sub>,y<sub>j</sub>) is the grid point to the bottom left of a given position (x,y) then we will label quantities within a grid cell as shown in Figure <a href="#fig:grid_cell">3.3</a> and define the following:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
<font face="symbol">a</font
> =  </td><td nowrap="nowrap" align="center">
&nbsp;x <font face="symbol">-</font
> x<sub>i</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">D</font
>x<br /></td><td nowrap="nowrap" align="center">
, <font face="symbol">b</font
> =  </td><td nowrap="nowrap" align="center">
&nbsp;y <font face="symbol">-</font
> y<sub>j</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">D</font
>y<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.78)</td></tr></table>


The bilinear interpolation equation in 2-D is:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
f(x,y) = (1<font face="symbol">-</font
><font face="symbol">a</font
>) (1<font face="symbol">-</font
><font face="symbol">b</font
>) f<sub>i,j</sub> <font face="symbol">-</font
> <font face="symbol">a</font
>(1<font face="symbol">-</font
><font face="symbol">b</font
>) f<sub>i+1,j</sub> + <font face="symbol">a</font
><font face="symbol">b</font
>f<sub>i+1,j+1</sub> <font face="symbol">-</font
> (1<font face="symbol">-</font
><font face="symbol">a</font
>) <font face="symbol">b</font
>f<sub>i,j+1</sub></td></tr></table>
</td><td width="1%">(3.79)</td></tr></table>



<div class="p"></div>
The bicubic interpolation method adds to this by using the derivatives of the function f at the four corners of the grid cell:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">¶</font
>f
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">¶</font
>x<br /></td><td nowrap="nowrap" align="center">
, </td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">¶</font
>f
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">¶</font
>y<br /></td><td nowrap="nowrap" align="center">
, </td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">¶</font
><sup>2</sup> f
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">¶</font
>x <font face="symbol">¶</font
>y<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.80)</td></tr></table>


In our case, since we do not know these derivatives, we calculate them numerically using centred differencing:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><font face="symbol">
æ<br />è
</font></td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">¶</font
>f
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">¶</font
>x<br /></td><td align="left" class="cl"><font face="symbol">
ö<br />ø
</font></td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><br />
<font size="-1">i,j</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
 = </td><td nowrap="nowrap" align="center">
&nbsp;f<sub>i+1,j</sub> <font face="symbol">-</font
> f<sub>i<font face="symbol">-</font
>1,j</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2 <font face="symbol">D</font
>x<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.81)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><font face="symbol">
æ<br />è
</font></td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">¶</font
>f
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">¶</font
>y<br /></td><td align="left" class="cl"><font face="symbol">
ö<br />ø
</font></td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><br />
<font size="-1">i,j</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
 = </td><td nowrap="nowrap" align="center">
&nbsp;f<sub>i,j+1</sub> <font face="symbol">-</font
> f<sub>i,j<font face="symbol">-</font
>1</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2 <font face="symbol">D</font
>y<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.82)</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td align="left" class="cl"><font face="symbol">
æ<br />è
</font></td><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">¶</font
><sup>2</sup> f
<div class="hrcomp"><hr noshade="noshade" size="1"/></div><font face="symbol">¶</font
>x <font face="symbol">¶</font
>y<br /></td><td align="left" class="cl"><font face="symbol">
ö<br />ø
</font></td><td nowrap="nowrap" align="center">
<font size="-1"></font><!--sup
--><br /><br />
<font size="-1">i,j</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
 = </td><td nowrap="nowrap" align="center">
&nbsp;f<sub>i+1,j+1</sub> <font face="symbol">-</font
> f<sub>i+1,j<font face="symbol">-</font
>1</sub> <font face="symbol">-</font
> f<sub>i<font face="symbol">-</font
>1,j+1</sub> + f<sub>i<font face="symbol">-</font
>1,j<font face="symbol">-</font
>1</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>4 <font face="symbol">D</font
>x <font face="symbol">D</font
>y<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td><td width="1%">(3.83)</td></tr></table>


The bicubic interpolation equation in 2-D uses these sixteen quantities via a linear interpolation equation (Equation <a href="#equn:bicubuc_interp">3.79</a>).  This equation involves a linear transformation matrix, <font face="helvetica">C</font>, which depends on the partial derivatives and is described in <a href="#press++92" name="CITEpress++92">Press <em>et&nbsp;al.</em> [1992]</a>:
<a name="equn:bicubuc_interp">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
f(x,y) = </td><td nowrap="nowrap" align="center">
<font size="-1">4</font><!--sup
--><br /><font size="+3"><font face="symbol">å<br />
</font></font><font size="-1">a=1</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<font size="-1">4</font><!--sup
--><br /><font size="+3"><font face="symbol">å<br />
</font></font><font size="-1">b=1</font>&nbsp;<br /></td><td nowrap="nowrap" align="center">
C<sub>ab</sub> &nbsp;<font face="symbol">a</font
><sup>a<font face="symbol">-</font
>1</sup> <font face="symbol">b</font
><sup>b<font face="symbol">-</font
>1</sup></td></tr></table>
</td><td width="1%">(3.84)</td></tr></table>



<div class="p"></div>
An alternative way to calculate the required derivatives is through the use of global 2-D splines. The actual process of interpolation is equivalent to 2-D bicubic interpolation. This interpolation scheme consists of two stages. The first stage produces an auxiliary table of spline coefficients in the x-direction. The second stage uses these coefficients to evaluate values in a line parallel to the y-axis with an x-coordinate equal to the position of the required value. A spline is then constructed to pass through all these points and a final spline evaluation is used to determine the final interpolated value.

<div class="p"></div>

<h4>Scheme comparison</h4>

<div class="p"></div>

<div class="p"></div>
<a name="tth_fIg3.4">
</a> <center><a href="figs/simulation/Bx_interp.eps">
<img alt="Bx_interp" src="images/Bx_interp.gif" border="0"></a>

<center>Figure 3.4: Graph comparing the B<sub>x</sub> field component interpolated using different interpolation schemes.  The interpolation methods used are bilinear (black), bicubic (blue) and splines (red).</center>
<a name="fig:interpolation_compare">
</a>
</center>
<div class="p"></div>
Figure <a href="#fig:interpolation_compare">3.4</a> compares the fields determined using different interpolation schemes along a single field slice.  The slice was taken along the line y=x from the shock simulation shown in Figure <a href="#fig:EB_fields">4.2</a>.  The bilinear scheme is significantly faster than the other two interpolation schemes.  However, bilinear interpolation produces discontinuities in the value of the field gradient, which would correspond to the introduction of high frequency field structure.  Bearing in mind the results of <a href="#kraussvarban++89" name="CITEkraussvarban++89">Krauss-Varban <em>et&nbsp;al.</em> [1989]</a>, which show that high frequency field structure is responsible for numerical scattering of electron pitch angles, this is clearly an undesirable characteristic.

<div class="p"></div>
The bicubic and spline interpolations provide similar results in that they both enforce smoothness of the field gradient.  Spline interpolation does, however, produce a larger overshoot where the field reaches a turning point.  It also requires us to specify boundary conditions at the edge of the simulation box, which may lead to the creation of artifacts.  It is also an implicit scheme, which has the undesirable property of allowing distant field structures to have an influence on local field properties.  The bicubic scheme is explicit and does not suffer from these drawbacks.  In addition, it has a lower computational cost and is easier to implement.  We have therefore used the bicubic method for spatial interpolation in our electron trajectory integrations.



<div class="p"></div>

<br /><br /><hr /><small>
Page Maintained By : 
Rob Lowe<BR>
Last Revision : 1st March 2003
</body>
</html> 